/**
 * Cache System Utilities
 *
 * Utility functions for cache operations following Black Box pattern.
 * Provides clean utility functions for validation, initialization, and management.
 */

import {
    CORE_CONSTANTS,
    CORE_VALIDATION_RULES,
    CORE_ERROR_CODES
} from '../shared';

import type {
    CacheConfig,
    CacheEntry,
    CacheStats,
    CacheStrategy
} from './interfaces';


/**
 * Validates cache configuration
 *
 * @param config - Configuration to validate
 * @returns Array of validation errors
 */
export function validateCacheConfig(config: any): string[] {
    const errors: string[] = [];

    if (!config || typeof config !== 'object') {
        errors.push('Configuration must be an object');
        return errors;
    }

    // Validate maxSize
    if (config.maxSize !== undefined) {
        const maxSizeRule = CORE_VALIDATION_RULES.cache.maxSize;
        if (config.maxSize < maxSizeRule.min || config.maxSize > maxSizeRule.max) {
            errors.push(`Cache maxSize must be between ${maxSizeRule.min} and ${maxSizeRule.max}`);
        }
    }

    // Validate defaultTtl
    if (config.defaultTtl !== undefined) {
        const ttlRule = CORE_VALIDATION_RULES.cache.defaultTtl;
        if (config.defaultTtl < ttlRule.min || config.defaultTtl > ttlRule.max) {
            errors.push(`Cache defaultTtl must be between ${ttlRule.min} and ${ttlRule.max}ms`);
        }
    }

    // Validate strategy
    if (config.strategy && !CORE_VALIDATION_RULES.cache.strategy.includes(config.strategy)) {
        errors.push(`Cache strategy must be one of: ${CORE_VALIDATION_RULES.cache.strategy.join(', ')}`);
    }

    return errors;
}

/**
 * Creates a default cache configuration
 *
 * @param overrides - Optional configuration overrides
 * @returns Default cache configuration
 */
export function createDefaultCacheConfig(overrides?: Partial<CacheConfig>): CacheConfig {
    return {
        maxSize: CORE_CONSTANTS.DEFAULT_CACHE_SIZE,
        defaultTTL: CORE_CONSTANTS.DEFAULT_CACHE_TTL,
        strategy: CORE_CONSTANTS.DEFAULT_CACHE_STRATEGY as CacheStrategy,
        enableMetrics: true,
        ...overrides
    };
}

/**
 * Creates a cache entry with metadata
 *
 * @param key - Cache key
 * @param value - Cache value
 * @param ttl - Time to live in milliseconds
 * @returns Cache entry with metadata
 */
export function createCacheEntry<T>(
    key: string,
    value: T,
    ttl?: number
): CacheEntry<T> {
    const timestamp = Date.now();
    const expiresAt = ttl ? timestamp + ttl : undefined;

    return {
        key,
        value,
        timestamp,
        ttl,
        expiresAt,
        size: calculateEntrySize(value)
    };
}

/**
 * Checks if a cache entry is expired
 *
 * @param entry - Cache entry to check
 * @returns True if entry is expired
 */
export function isEntryExpired<T>(entry: CacheEntry<T>): boolean {
    if (!entry.expiresAt) {
        return false;
    }

    return Date.now() > entry.expiresAt;
}

/**
 * Calculates the size of a cache entry
 *
 * @param value - Value to calculate size for
 * @returns Estimated size in bytes
 */
export function calculateEntrySize(value: any): number {
    if (value === null || value === undefined) {
        return 0;
    }

    if (typeof value === 'string') {
        return value.length * 2; // UTF-16 characters
    }

    if (typeof value === 'number') {
        return 8; // 64-bit number
    }

    if (typeof value === 'boolean') {
        return 4; // boolean
    }

    if (value instanceof Date) {
        return 8; // timestamp
    }

    if (Array.isArray(value)) {
        return value.reduce((total, item) => total + calculateEntrySize(item), 0);
    }

    if (typeof value === 'object') {
        return JSON.stringify(value).length * 2;
    }

    return 0;
}

/**
 * Merges cache statistics
 *
 * @param stats1 - First statistics object
 * @param stats2 - Second statistics object
 * @returns Merged statistics
 */
export function mergeCacheStats(stats1: CacheStats, stats2: CacheStats): CacheStats {
    return {
        size: stats1.size + stats2.size,
        hits: stats1.hits + stats2.hits,
        misses: stats1.misses + stats2.misses,
        hitRate: calculateHitRate(stats1.hits + stats2.hits, stats1.misses + stats2.misses),
        memoryUsage: stats1.memoryUsage + stats2.memoryUsage,
        evictions: stats1.evictions + stats2.evictions,
        sets: stats1.sets + stats2.sets,
        gets: stats1.gets + stats2.gets,
        deletes: stats1.deletes + stats2.deletes,
        createdAt: Math.min(stats1.createdAt, stats2.createdAt),
        updatedAt: Math.max(stats1.updatedAt, stats2.updatedAt)
    };
}

/**
 * Calculates cache hit rate
 *
 * @param hits - Number of hits
 * @param misses - Number of misses
 * @returns Hit rate as percentage (0-1)
 */
export function calculateHitRate(hits: number, misses: number): number {
    const total = hits + misses;
    return total === 0 ? 0 : hits / total;
}

/**
 * Formats cache statistics for display
 *
 * @param stats - Cache statistics
 * @returns Formatted statistics string
 */
export function formatCacheStats(stats: CacheStats): string {
    return `Cache Stats:
  Size: ${stats.size} entries
  Hit Rate: ${(stats.hitRate * 100).toFixed(2)}%
  Memory Usage: ${formatBytes(stats.memoryUsage)}
  Hits: ${stats.hits}
  Misses: ${stats.misses}
  Evictions: ${stats.evictions}
  Sets: ${stats.sets}
  Gets: ${stats.gets}
  Deletes: ${stats.deletes}`;
}

/**
 * Formats bytes to human readable format
 *
 * @param bytes - Number of bytes
 * @returns Formatted string
 */
export function formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B';

    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

/**
 * Generates a cache key from parameters
 *
 * @param params - Parameters to generate key from
 * @returns Generated cache key
 */
export function generateCacheKey(...params: any[]): string {
    return params
        .map(param => {
            if (param === null || param === undefined) {
                return 'null';
            }
            if (typeof param === 'object') {
                return JSON.stringify(param);
            }
            return String(param);
        })
        .join(':');
}

/**
 * Parses a cache key into components
 *
 * @param key - Cache key to parse
 * @returns Array of key components
 */
export function parseCacheKey(key: string): string[] {
    return key.split(':');
}

/**
 * Creates a cache error with proper error code
 *
 * @param message - Error message
 * @param code - Error code
 * @param details - Additional error details
 * @returns Cache error object
 */
export function createCacheError(
    message: string,
    code: string = CORE_ERROR_CODES.CACHE_ERROR,
    details?: any
): Error {
    const error = new Error(message) as any;
    error.code = code;
    error.details = details;
    error.timestamp = Date.now();
    return error;
}

/**
 * Checks if a key is valid for cache storage
 *
 * @param key - Key to validate
 * @returns True if key is valid
 */
export function isValidCacheKey(key: string): boolean {
    if (!key || typeof key !== 'string') {
        return false;
    }

    // Check length
    if (key.length === 0 || key.length > 255) {
        return false;
    }

    // Check for invalid characters
    const invalidChars = [' ', '\t', '\n', '\r'];
    return !invalidChars.some(char => key.includes(char));
}

/**
 * Sanitizes a cache key
 *
 * @param key - Key to sanitize
 * @returns Sanitized key
 */
export function sanitizeCacheKey(key: string): string {
    return key
        .replace(/\s+/g, '_')
        .replace(/[^a-zA-Z0-9_:.-]/g, '')
        .toLowerCase();
}

/**
 * Creates a cache TTL from time units
 *
 * @param seconds - Number of seconds
 * @returns TTL in milliseconds
 */
export function createTTL(seconds: number): number {
    return seconds * 1000;
}

/**
 * Creates a cache TTL from minutes
 *
 * @param minutes - Number of minutes
 * @returns TTL in milliseconds
 */
export function createTTLFromMinutes(minutes: number): number {
    return minutes * 60 * 1000;
}

/**
 * Creates a cache TTL from hours
 *
 * @param hours - Number of hours
 * @returns TTL in milliseconds
 */
export function createTTLFromHours(hours: number): number {
    return hours * 60 * 60 * 1000;
}

/**
 * Creates a cache TTL from days
 *
 * @param days - Number of days
 * @returns TTL in milliseconds
 */
export function createTTLFromDays(days: number): number {
    return days * 24 * 60 * 60 * 1000;
}

/**
 * Gets remaining TTL for a cache entry
 *
 * @param entry - Cache entry
 * @returns Remaining TTL in milliseconds, or null if no TTL
 */
export function getRemainingTTL<T>(entry: CacheEntry<T>): number | null {
    if (!entry.expiresAt) {
        return null;
    }

    const remaining = entry.expiresAt - Date.now();
    return remaining > 0 ? remaining : 0;
}

/**
 * Extends the TTL of a cache entry
 *
 * @param entry - Cache entry to extend
 * @param additionalTTL - Additional TTL in milliseconds
 * @returns Updated cache entry
 */
export function extendEntryTTL<T>(
    entry: CacheEntry<T>,
    additionalTTL: number
): CacheEntry<T> {
    const newExpiresAt = entry.expiresAt
        ? entry.expiresAt + additionalTTL
        : Date.now() + additionalTTL;

    return {
        ...entry,
        expiresAt: newExpiresAt,
        ttl: additionalTTL
    };
}
